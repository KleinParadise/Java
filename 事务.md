### 事务的四个性质
	- 原子性
		- 事务中包含的所有操作,要么全做,要么全不做
	- 一致性
		- 一个事务执行之前和执行之后都必须处于一致性状态
		- 假设用户A和用户B两者的钱加起来一共是5000,那么不管A和B之间如何转账,转几次账,事务结束后两个用户的钱相加起来应该还得是5000,这就是事务的一致性。
	- 隔离性
		- 系统必须保证事务不受其他并发执行的事务的影响,每个事务都感觉不到系统中有其他事务在并发地执行
	- 持久性
		- 一个事务一旦成功完成，它对数据库的改变必须是永久的,即使系统故障也不丢失数据


### 脏读,不可重复读,幻读
	- 脏读 读取到另一个事务未提交的数据的现象就是脏读
	- 不可重复读 在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读
	- 幻读 事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。


### 不可重复读与脏读的区别
	- 脏读是某一事务读取了另一个事务未提交的脏数据
	- 不可重复读则是读取了前一事务提交的数据。

### 不可重复读与幻读的区别
	- 不可重复读是读取了其他事务更改的数据，针对update操作
		- 使用行级锁,锁定该行,事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。
	- 幻读是读取了其他事务新增的数据，针对insert和delete操作
		- 使用表级锁,锁定整张表,事务A多次读取数据总量之后才释放该锁,这个时候才允许其他事务新增数据。

### 事务的隔离级别
	- 读未提交
		- 是最低的隔离级别,所有的事务都可以看到其他未提交的事务的执行结果,不能解决脏读,可重复读,幻读
	- 读提交rc
		- 一个事务的更新操作结果只有在该事务提交之后,另一个事务才可能读取到同一笔数据更新后的结果。可防止脏读,不能解决可重复读,幻读
		- 数据的读取都是不加锁的,但是数据的写入,修改,删除是需要加锁的。
	- 可重复读 rr
		- 一个事务多次读同一个数据,在这个事务还没结束时,其他事务不能访问该数据(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的可防止脏读,可重复读,不能解决幻读
		- 不可重复读解决方式
			- 悲观锁
			- mysql通过基于乐观锁的mvcc(多版本并发控制)解决不可重复读的问题
				- MVCC是通过ReadView+ UndoLog实现的，UndoLog保存了历史快照,ReadView规则帮助判断当前版本的数据是否可见。
			- mysql通过Next-key锁解决幻读问题
				- Next-Key锁是行锁和GAP（间隙锁）的合并
				- 行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况
				- GAP（间隙锁）解决别的事务插入数据的问题
	- 串行化
		- 在该级别下,事务顺序执行。避免脏读、不可重复读,幻读但是效率最低

### 事务的传播行为

### mysql锁的种类
	- 表锁
		- 表锁是对一整张表加锁,导致并发能力下降
	- 行锁
		- 行锁则是锁住数据行,由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强。mysql通过行锁来处理并发事务

### 悲观锁与乐观锁
	- 悲观锁 在整个数据处理过程中,将数据处于锁定状态
	- 乐观锁 大多是基于数据版本version记录机制实现,即为数据增加一个版本标识,读取出数据时,将此版本号一同读出,之后更新时,对此版本号加一。提交数据的版本数据与数据库表对应记录的当前版本信息进行比对,如果提交的数据版本号大于数据库表当前版本号,则予以更新,否则认为是过期数据。

### 事务的自动提交
	- 如果不是显式地开始一个事务，每一次 SQL操作(非select操作)都会自动提交一个事务

### MySQL存储引擎
	- InnoDB引擎和MyISAM存储引擎，InnoDB是MySQL的默认事务引擎。
